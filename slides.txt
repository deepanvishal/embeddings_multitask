Slide 1 — Purpose, Scale & Scope
Title:
Provider Utilization Embeddings: Foundational Representation for Network Analytics
Bullets (Crisp, Non-Rambling)

We built a provider-level utilization embedding that summarizes each provider’s procedure mix, diagnosis mix, cost patterns, place of service, and patient volume into a compact vector representation.

This embedding serves as a foundational, reusable asset for any downstream modeling or analytics — including ProNet 2.0, provider substitution, network simulation, and utilization pattern analysis.

Data Window: Claims from 2023–2024.

Initial Cohort: ~60,000 provider entities.

Focus: Hospitals and facilities only (specialists excluded in this phase).

Stability Filters Applied:

≥ 156 total claims

≥ 10 distinct treatment codes

≥ 8 distinct diagnosis codes

Filters chosen based on empirical distribution breakpoints to ensure stable utilization signals.

Final Modeling Cohort: 25,347 providers that meet minimum utilization diversity and volume thresholds.

The goal at this stage is not to tie the embeddings to an immediate metric, but to deliver a consistent, scalable provider representation that other teams can use directly.


SLIDE 1: OVERVIEW
Overview
Representing providers based on their utilization patterns is complicated due to high dimensionality from thousands of procedure and diagnosis codes, resulting in extremely sparse data. We're creating embeddings to solve this challenge.
Scope

Data Source: 2023-2024 claims data
Provider Type: Hospitals and facilities only (no specialists)
Initial Pool: 60,000+ providers in claims
Final Cohort: 25,347 providers after filtering
Filtering Criteria:

Minimum 156 claims per provider
At least 10 unique procedure codes
At least 8 unique diagnosis codes



Solution: ME2Vec (Medical Entity to Vector)

Graph-based embeddings that capture provider utilization patterns
Converts sparse procedure/diagnosis codes into dense vector representations
Enables efficient similarity calculations between providers

Output

Dense embeddings for each provider
Any team can use for their analytics needs
First application: ProNet 2.0 network simulation



SLIDE 2: ME2VEC ARCHITECTURE
Three-Step Embedding Pipeline
Step 1: Procedure Code Embeddings (Node2Vec)

Build co-occurrence graph between procedure codes (codes that appear together for same providers)
Generate biased random walks on the procedure graph
Train Word2Vec on walks to create 128-dim procedure embeddings
Parameters: 80-length walks, 10 walks per node, p=4.0, q=1.0

Step 2: Initialize Provider Embeddings

Weighted average of procedure code embeddings
Weight = claim frequency for each procedure
Creates initial 128-dim provider representation

Step 3: GAT Refinement for Final Embeddings

Multi-head Graph Attention Network (4 heads)
Learns which procedure codes are most important for each provider
Attention mechanism weights the importance of different procedures
Outputs: 512-dim refined provider embeddings (128 dim × 4 heads)
Trained using specialty labels as supervision signal


Conceptual Flow (Crisp + Accurate)

1. Utilization Patterns as Inputs
We begin by summarizing each provider’s utilization across procedures and diagnoses.
These patterns create a behavioral “fingerprint” of how each facility is used.

2. ME2Vec Embeddings
Using a co-occurrence–based neural model (similar to Word2Vec), we learn:

Procedure embeddings (how procedures relate to one another)

Diagnosis embeddings (how diagnoses relate based on patterns of co-treatment)
Providers receive an initial vector by aggregating the embeddings of the codes they perform most.

3. Specialty-Aware Refinement (Attention Layer)
A Graph Attention layer adjusts each provider’s embedding by highlighting the most representative procedure/diagnosis patterns.
Specialty labels (where available) help the model organize providers into clinically meaningful patterns.

4. Multi-Tower Provider Representation
In addition to ME2Vec embeddings, we incorporate structured provider features (“towers”):

Cost categories

Place of service

Demographics

Provider size/volume metrics
All towers are standardized and concatenated with the ME2Vec embeddings.

5. Final Representation (1,046 dimensions)
The output is a unified embedding that captures a provider’s overall utilization behavior — ready for similarity modeling and downstream simulation.

Visual Summary (for your slide layout)

Utilization → ME2Vec (proc + diag) → Attention refinement → Add towers → Final provider vector

Hi Danielle,

I’ve put together a deck summarizing the Embeddings Model, and I’ve attached the PowerPoint for your review.

The deck includes:

Overview

Model Architecture

Threshold methodology with sample results

Alternative methods considered

Rare/Unique services and proposed next steps

I’ve also included additional technical details in the appendix for reference.

Please let me know if the narrative flow works or if you’d like any adjustments.

Thanks,
Deepan


Substance Abuse Curation:
Measured the extent of adverse selection in curated vs. non-curated scenarios and quantified how much risk was avoided because of the curation strategy.

Redistribution Model:
Developed the initial logistic-regression model to estimate redistribution likelihood and then evolved it into an embeddings-based framework for better scalability and pattern capture.

Provider Embeddings:
Built an embeddings model using utilization and demographic data; the work is in progress, with multiple rounds of feedback incorporated and alignment secured from technical SMEs.

I actively discussed and reviewed development actions with my leader to strengthen my performance and align with the expectations of my new role, focusing on building consistency, clarity, and scale in my work.



# OLD (could create 0-d array):
a_attention = np.array(a_data['attention']) if a_data['attention'] else np.array([])
if len(a_codes) > 0 and len(a_attention) > 0:  # ← Error here if 0-d array

# NEW (safe):
a_attention_list = a_data['attention'] if a_data['attention'] else []
a_attention = np.array(a_attention_list) if a_attention_list else np.array([])
if len(a_codes) > 0 and len(a_attention_list) > 0:  # ← Check list, not numpy array


